<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Otomatis - Deteksi Pola Banjir</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.17.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .highlight-box {
            background: linear-gradient(45deg, rgba(255, 215, 0, 0.2), rgba(255, 165, 0, 0.2));
            border: 2px solid #ffd700;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }
        
        .highlight-title {
            font-size: 1.4em;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 10px;
        }
        
        .section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        label {
            font-weight: bold;
            font-size: 0.9em;
        }
        
        input, select, button {
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #ffd700;
        }
        
        .metric-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        .log {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.9em;
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
        }
        
        .prediction-result {
            font-size: 1.5em;
            text-align: center;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: bold;
        }
        
        .status-1 { background: linear-gradient(45deg, #2ecc71, #27ae60); }
        .status-2 { background: linear-gradient(45deg, #f39c12, #e67e22); }
        .status-3 { background: linear-gradient(45deg, #e74c3c, #c0392b); }
        
        .confidence-bars {
            margin: 20px 0;
        }
        
        .confidence-item {
            display: flex;
            align-items: center;
            margin: 10px 0;
            gap: 15px;
        }
        
        .confidence-label {
            width: 120px;
            font-weight: bold;
        }
        
        .confidence-bar {
            flex: 1;
            height: 25px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }
        
        .confidence-fill {
            height: 100%;
            border-radius: 12px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .learned-patterns {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .pattern-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #00d2ff;
        }
        
        .feature-importance {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .feature-bar {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
        }
        
        .feature-name {
            font-size: 0.9em;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff9a9e, #fad0c4);
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        .data-analysis {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .analysis-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }
        
        .analysis-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #00d2ff;
        }
        
        .neural-viz {
            margin: 20px 0;
            text-align: center;
        }
        
        .layer-info {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px 15px;
            margin: 5px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß† Neural Network Otomatis - Deteksi Pola Banjir</h1>
        
        <div class="highlight-box">
            <div class="highlight-title">üéØ Pure Neural Network Learning</div>
            <p>Sistem ini akan belajar pola secara otomatis dari data tanpa threshold manual.<br>
            NN akan menemukan sendiri hubungan antara input (water level, rainfall) dan output (status).</p>
        </div>

        <div class="section">
            <h2>üìä Data Loading & Auto-Analysis</h2>
            <div class="control-panel">
                <div class="input-group">
                    <label>Upload Data CSV:</label>
                    <input type="file" id="csvFile" accept=".csv">
                </div>
                <div class="input-group">
                    <label>Auto Feature Engineering:</label>
                    <select id="featureEngineering">
                        <option value="basic">Basic (Water Level + Rainfall)</option>
                        <option value="temporal" selected>Temporal (+ Time features)</option>
                        <option value="advanced">Advanced (+ Statistical features)</option>
                    </select>
                </div>
                <div class="input-group">
                    <button id="loadData">üìÅ Load & Auto-Analyze</button>
                </div>
            </div>
            <div id="dataInfo" class="log"></div>
            
            <div id="dataAnalysis" class="data-analysis" style="display:none;">
                <div class="analysis-card">
                    <div class="analysis-value" id="totalSamples">-</div>
                    <div>Total Samples</div>
                </div>
                <div class="analysis-card">
                    <div class="analysis-value" id="featureCount">-</div>
                    <div>Features Generated</div>
                </div>
                <div class="analysis-card">
                    <div class="analysis-value" id="classBalance">-</div>
                    <div>Class Balance</div>
                </div>
                <div class="analysis-card">
                    <div class="analysis-value" id="dataQuality">-</div>
                    <div>Data Quality</div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>üß† Neural Network Auto-Configuration</h2>
            <div class="control-panel">
                <div class="input-group">
                    <label>Network Complexity:</label>
                    <select id="networkComplexity">
                        <option value="simple">Simple (Fast training)</option>
                        <option value="medium" selected>Medium (Balanced)</option>
                        <option value="complex">Complex (High accuracy)</option>
                        <option value="auto">Auto (Let NN decide)</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>Learning Strategy:</label>
                    <select id="learningStrategy">
                        <option value="standard">Standard Training</option>
                        <option value="adaptive" selected>Adaptive Learning</option>
                        <option value="ensemble">Ensemble Network</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>Training Patience:</label>
                    <select id="trainingPatience">
                        <option value="fast">Fast (50 epochs max)</option>
                        <option value="normal" selected>Normal (100 epochs max)</option>
                        <option value="thorough">Thorough (200 epochs max)</option>
                    </select>
                </div>
                <div class="input-group">
                    <button id="autoTrain">üöÄ Auto-Train Neural Network</button>
                </div>
            </div>
            
            <div id="networkViz" class="neural-viz" style="display:none;">
                <h3>üèóÔ∏è Auto-Generated Network Architecture:</h3>
                <div id="layerInfo"></div>
            </div>
            
            <div id="trainingProgress" style="display:none;">
                <h3>üìà Training Progress:</h3>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div id="trainingLog" class="log"></div>
            </div>
        </div>

        <div class="section" id="resultsSection" style="display:none;">
            <h2>üìä Auto-Learning Results</h2>
            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-value" id="finalAccuracy">-</div>
                    <div class="metric-label">Final Accuracy</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="validationScore">-</div>
                    <div class="metric-label">Validation Score</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="learningTime">-</div>
                    <div class="metric-label">Learning Time</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="modelComplexity">-</div>
                    <div class="metric-label">Model Complexity</div>
                </div>
            </div>
            
            <div class="learned-patterns">
                <h3>üîç Patterns Learned by Neural Network:</h3>
                <div id="learnedPatterns"></div>
            </div>
            
            <div class="feature-importance">
                <h3>üéØ Auto-Discovered Feature Importance:</h3>
                <div id="featureImportance"></div>
            </div>
        </div>

        <div class="section" id="predictionSection" style="display:none;">
            <h2>üîÆ Pure Neural Network Prediction</h2>
            <p style="text-align: center; opacity: 0.9;">
                <em>Input your values and let the neural network decide the status based on learned patterns</em>
            </p>
            
            <div class="control-panel">
                <div class="input-group">
                    <label>Water Level / Distance (cm):</label>
                    <input type="number" id="inputWaterLevel" value="200" step="0.1">
                </div>
                <div class="input-group">
                    <label>Rainfall (mm/h):</label>
                    <input type="number" id="inputRainfall" value="0" step="0.1">
                </div>
                <div class="input-group">
                    <label>Time Context (hour of day):</label>
                    <input type="number" id="inputTimeContext" value="12" min="0" max="23">
                </div>
                <div class="input-group">
                    <button id="predictButton">üß† Neural Network Predict</button>
                </div>
            </div>
            
            <div id="predictionResult" class="prediction-result" style="display:none;"></div>
            
            <div id="confidenceSection" style="display:none;">
                <h3>üéØ Neural Network Confidence:</h3>
                <div class="confidence-bars">
                    <div class="confidence-item">
                        <div class="confidence-label">Status 1</div>
                        <div class="confidence-bar">
                            <div class="confidence-fill status-1" id="conf1">0%</div>
                        </div>
                    </div>
                    <div class="confidence-item">
                        <div class="confidence-label">Status 2</div>
                        <div class="confidence-bar">
                            <div class="confidence-fill status-2" id="conf2">0%</div>
                        </div>
                    </div>
                    <div class="confidence-item">
                        <div class="confidence-label">Status 3</div>
                        <div class="confidence-bar">
                            <div class="confidence-fill status-3" id="conf3">0%</div>
                        </div>
                    </div>
                </div>
                
                <div id="neuralExplanation" class="pattern-card" style="display:none;">
                    <h4>ü§ñ Neural Network Reasoning:</h4>
                    <div id="reasoningText"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let model = null;
        let scaler = null;
        let rawData = [];
        let processedData = [];
        let featureNames = [];
        let modelArchitecture = null;

        // Utility functions
        function log(message) {
            const logElement = document.getElementById('dataInfo');
            logElement.innerHTML += message + '<br>';
            logElement.scrollTop = logElement.scrollHeight;
        }

        function trainingLog(message) {
            const logElement = document.getElementById('trainingLog');
            logElement.innerHTML += message + '<br>';
            logElement.scrollTop = logElement.scrollHeight;
        }

        // Advanced feature engineering
        function engineerFeatures(data, mode) {
            const features = [];
            
            for (let i = 2; i < data.length; i++) {
                const current = data[i];
                const prev1 = data[i - 1];
                const prev2 = data[i - 2];
                
                // Basic features
                const feature = {
                    water_level: current.water_level,
                    rainfall: current.rainfall,
                    status: current.status
                };
                
                if (mode === 'temporal' || mode === 'advanced') {
                    // Temporal features
                    feature.water_level_change_1 = current.water_level - prev1.water_level;
                    feature.water_level_change_2 = prev1.water_level - prev2.water_level;
                    feature.rainfall_change = current.rainfall - prev1.rainfall;
                    
                    // Time-based features
                    if (current.timestamp) {
                        const date = new Date(current.timestamp);
                        feature.hour_of_day = date.getHours();
                        feature.day_of_week = date.getDay();
                    } else {
                        feature.hour_of_day = 12; // default
                        feature.day_of_week = 1; // default
                    }
                }
                
                if (mode === 'advanced') {
                    // Statistical features
                    const recent_water_levels = [current.water_level, prev1.water_level, prev2.water_level];
                    feature.water_level_mean_3 = recent_water_levels.reduce((a, b) => a + b, 0) / 3;
                    feature.water_level_std_3 = Math.sqrt(recent_water_levels.reduce((sq, n) => sq + Math.pow(n - feature.water_level_mean_3, 2), 0) / 3);
                    
                    const recent_rainfall = [current.rainfall, prev1.rainfall, prev2.rainfall];
                    feature.rainfall_sum_3 = recent_rainfall.reduce((a, b) => a + b, 0);
                    
                    // Interaction features
                    feature.water_rain_interaction = current.water_level * current.rainfall;
                    feature.trend_magnitude = Math.abs(feature.water_level_change_1) + Math.abs(feature.water_level_change_2);
                }
                
                features.push(feature);
            }
            
            return features;
        }

        // Auto-normalization
        function autoNormalize(data) {
            const features = Object.keys(data[0]).filter(key => key !== 'status');
            const scalerInfo = {};
            
            features.forEach(feature => {
                const values = data.map(d => d[feature]).filter(v => !isNaN(v));
                const min = Math.min(...values);
                const max = Math.max(...values);
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const std = Math.sqrt(values.reduce((sq, n) => sq + Math.pow(n - mean, 2), 0) / values.length);
                
                scalerInfo[feature] = { min, max, mean, std };
            });
            
            const normalized = data.map(row => {
                const normalizedRow = { ...row };
                features.forEach(feature => {
                    const { min, max } = scalerInfo[feature];
                    // Use min-max normalization
                    normalizedRow[feature] = max === min ? 0 : (row[feature] - min) / (max - min);
                });
                return normalizedRow;
            });
            
            featureNames = features;
            return { normalized, scalerInfo };
        }

        // Auto-architecture generation
        function generateArchitecture(inputSize, complexity, sampleSize) {
            let layers = [];
            
            if (complexity === 'auto') {
                // Auto-determine complexity based on data size and input features
                if (sampleSize > 1000 && inputSize > 8) {
                    complexity = 'complex';
                } else if (sampleSize > 500 || inputSize > 5) {
                    complexity = 'medium';
                } else {
                    complexity = 'simple';
                }
            }
            
            switch (complexity) {
                case 'simple':
                    layers = [
                        { type: 'dense', units: Math.max(8, inputSize * 2), activation: 'relu' },
                        { type: 'dense', units: 3, activation: 'softmax' }
                    ];
                    break;
                    
                case 'medium':
                    layers = [
                        { type: 'dense', units: Math.max(16, inputSize * 3), activation: 'relu' },
                        { type: 'dropout', rate: 0.2 },
                        { type: 'dense', units: Math.max(8, inputSize * 2), activation: 'relu' },
                        { type: 'dense', units: 3, activation: 'softmax' }
                    ];
                    break;
                    
                case 'complex':
                    layers = [
                        { type: 'dense', units: Math.max(32, inputSize * 4), activation: 'relu' },
                        { type: 'dropout', rate: 0.3 },
                        { type: 'dense', units: Math.max(16, inputSize * 2), activation: 'relu' },
                        { type: 'dropout', rate: 0.2 },
                        { type: 'dense', units: Math.max(8, inputSize), activation: 'relu' },
                        { type: 'dense', units: 3, activation: 'softmax' }
                    ];
                    break;
            }
            
            return layers;
        }

        // File loading
        document.getElementById('csvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const csv = e.target.result;
                    if (typeof Papa === 'undefined') {
                        log('‚ùå CSV Parser not loaded. Please refresh the page.');
                        return;
                    }
                    
                    Papa.parse(csv, {
                        header: false,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            rawData = results.data.map(row => ({
                                id: row[0],
                                rainfall: row[1] || 0,
                                unknown: row[2] || 0,
                                water_level: row[3] || 0,
                                timestamp: row[4],
                                status: row[5] || 1
                            }));
                            log(`‚úÖ Loaded ${rawData.length} raw data points`);
                        }
                    });
                };
                reader.readAsText(file);
            }
        });

        // Data processing
        document.getElementById('loadData').addEventListener('click', function() {
            if (rawData.length === 0) {
                log('‚ùå Please load CSV file first');
                return;
            }

            log('üîÑ Auto-analyzing data and engineering features...');
            
            const engineeringMode = document.getElementById('featureEngineering').value;
            
            // Engineer features
            processedData = engineerFeatures(rawData, engineeringMode);
            log(`‚úÖ Generated ${processedData.length} processed samples`);
            
            // Analyze data quality
            const statusCounts = {};
            let validSamples = 0;
            
            processedData.forEach(row => {
                if (!isNaN(row.water_level) && !isNaN(row.rainfall) && row.status) {
                    statusCounts[row.status] = (statusCounts[row.status] || 0) + 1;
                    validSamples++;
                }
            });
            
            const featureCount = Object.keys(processedData[0]).length - 1; // exclude status
            const classBalance = Math.min(...Object.values(statusCounts)) / Math.max(...Object.values(statusCounts));
            const dataQuality = (validSamples / processedData.length) * 100;
            
            // Update analysis display
            document.getElementById('totalSamples').textContent = validSamples;
            document.getElementById('featureCount').textContent = featureCount;
            document.getElementById('classBalance').textContent = (classBalance * 100).toFixed(0) + '%';
            document.getElementById('dataQuality').textContent = dataQuality.toFixed(0) + '%';
            document.getElementById('dataAnalysis').style.display = 'grid';
            
            log(`üìä Status distribution: ${JSON.stringify(statusCounts)}`);
            log(`üéØ Generated ${featureCount} features automatically`);
            log(`‚öñÔ∏è Class balance ratio: ${(classBalance * 100).toFixed(1)}%`);
            log(`‚úîÔ∏è Data quality score: ${dataQuality.toFixed(1)}%`);
            
            // Auto-recommendations
            if (classBalance < 0.5) {
                log('‚ö†Ô∏è Recommendation: Consider data balancing techniques');
            }
            if (dataQuality < 90) {
                log('‚ö†Ô∏è Recommendation: Check for missing or invalid data');
            }
            if (featureCount > 15) {
                log('üí° Recommendation: Feature selection might improve performance');
            }
        });

        // Auto-training
        document.getElementById('autoTrain').addEventListener('click', async function() {
            if (processedData.length === 0) {
                trainingLog('‚ùå Please process data first');
                return;
            }

            document.getElementById('trainingProgress').style.display = 'block';
            trainingLog('üöÄ Starting automatic neural network training...');

            const complexity = document.getElementById('networkComplexity').value;
            const strategy = document.getElementById('learningStrategy').value;
            const patience = document.getElementById('trainingPatience').value;

            try {
                // Auto-normalize data
                const { normalized, scalerInfo } = autoNormalize(processedData);
                scaler = scalerInfo;
                
                // Prepare training data
                const X = normalized.map(row => featureNames.map(f => row[f]));
                const y = normalized.map(row => row.status - 1); // Convert to 0-indexed
                
                // Auto-split data
                const splitIndex = Math.floor(X.length * 0.8);
                const xTrain = X.slice(0, splitIndex);
                const yTrain = y.slice(0, splitIndex);
                const xTest = X.slice(splitIndex);
                const yTest = y.slice(splitIndex);
                
                trainingLog(`üì¶ Auto-split: Train ${xTrain.length}, Test ${xTest.length}`);
                trainingLog(`üéØ Features: ${featureNames.join(', ')}`);

                // Convert to tensors
                const xTrainTensor = tf.tensor2d(xTrain);
                const yTrainTensor = tf.oneHot(tf.tensor1d(yTrain, 'int32'), 3);
                const xTestTensor = tf.tensor2d(xTest);
                const yTestTensor = tf.oneHot(tf.tensor1d(yTest, 'int32'), 3);

                // Auto-generate architecture
                modelArchitecture = generateArchitecture(featureNames.length, complexity, xTrain.length);
                
                // Build model
                const tfLayers = [];
                modelArchitecture.forEach((layer, i) => {
                    if (layer.type === 'dense') {
                        if (i === 0) {
                            tfLayers.push(tf.layers.dense({ 
                                inputShape: [featureNames.length], 
                                units: layer.units, 
                                activation: layer.activation 
                            }));
                        } else {
                            tfLayers.push(tf.layers.dense({ 
                                units: layer.units, 
                                activation: layer.activation 
                            }));
                        }
                    } else if (layer.type === 'dropout') {
                        tfLayers.push(tf.layers.dropout({ rate: layer.rate }));
                    }
                });

                model = tf.sequential({ layers: tfLayers });

                // Auto-determine learning rate based on strategy
                let learningRate = 0.01;
                if (strategy === 'adaptive') {
                    learningRate = 0.001; // Start conservative for adaptive learning
                } else if (strategy === 'ensemble') {
                    learningRate = 0.005; // Moderate for ensemble
                }

                model.compile({
                    optimizer: tf.train.adam(learningRate),
                    loss: 'categoricalCrossentropy',
                    metrics: ['accuracy']
                });

                // Display auto-generated architecture
                document.getElementById('networkViz').style.display = 'block';
                const layerInfo = document.getElementById('layerInfo');
                layerInfo.innerHTML = '';
                modelArchitecture.forEach((layer, i) => {
                    const div = document.createElement('div');
                    div.className = 'layer-info';
                    if (layer.type === 'dense') {
                        div.textContent = `Layer ${i + 1}: Dense(${layer.units}) - ${layer.activation}`;
                    } else if (layer.type === 'dropout') {
                        div.textContent = `Layer ${i + 1}: Dropout(${layer.rate})`;
                    }
                    layerInfo.appendChild(div);
                });

                trainingLog(`üß† Auto-generated ${complexity} architecture with ${modelArchitecture.length} layers`);

                // Determine max epochs based on patience
                let maxEpochs = patience === 'fast' ? 50 : patience === 'normal' ? 100 : 200;
                
                const startTime = Date.now();
                let bestAccuracy = 0;
                let patienceCounter = 0;
                let earlyStopEpoch = maxEpochs;
                
                // Training with early stopping
                await model.fit(xTrainTensor, yTrainTensor, {
                    epochs: maxEpochs,
                    batchSize: Math.min(32, Math.floor(xTrain.length / 10)),
                    validationData: [xTestTensor, yTestTensor],
                    callbacks: {
                        onEpochEnd: (epoch, logs) => {
                            const progress = ((epoch + 1) / maxEpochs) * 100;
                            document.getElementById('progressFill').style.width = progress + '%';
                            
                            // Early stopping logic
                            if (logs.val_acc > bestAccuracy) {
                                bestAccuracy = logs.val_acc;
                                patienceCounter = 0;
                            } else {
                                patienceCounter++;
                            }
                            
                            // Stop if no improvement for 10 epochs
                            if (patienceCounter >= 10 && epoch > 20) {
                                earlyStopEpoch = epoch + 1;
                                trainingLog(`üõë Early stopping at epoch ${earlyStopEpoch} (best val_acc: ${bestAccuracy.toFixed(4)})`);
                                model.stopTraining = true;
                            }
                            
                            if ((epoch + 1) % 10 === 0 || epoch < 5) {
                                trainingLog(`Epoch ${epoch + 1}: loss=${logs.loss.toFixed(4)}, acc=${logs.acc.toFixed(4)}, val_acc=${logs.val_acc.toFixed(4)}`);
                            }
                        }
                    }
                });

                const trainingTime = (Date.now() - startTime) / 1000;
                
                // Final evaluation
                const trainEval = model.evaluate(xTrainTensor, yTrainTensor);
                const testEval = model.evaluate(xTestTensor, yTestTensor);
                
                const trainAcc = await trainEval[1].data();
                const testAcc = await testEval[1].data();
                const finalLoss = await trainEval[0].data();

                // Update results
                document.getElementById('finalAccuracy').textContent = (testAcc[0] * 100).toFixed(1) + '%';
                document.getElementById('validationScore').textContent = (testAcc[0] * 100).toFixed(1) + '%';
                document.getElementById('learningTime').textContent = trainingTime.toFixed(1) + 's';
                document.getElementById('modelComplexity').textContent = modelArchitecture.length + ' layers';

                document.getElementById('resultsSection').style.display = 'block';
                document.getElementById('predictionSection').style.display = 'block';

                trainingLog(`‚úÖ Auto-training completed in ${trainingTime.toFixed(1)}s`);
                trainingLog(`üéØ Final Test Accuracy: ${(testAcc[0] * 100).toFixed(1)}%`);
                trainingLog(`üìä Model stopped at epoch ${earlyStopEpoch}/${maxEpochs}`);

                // Analyze learned patterns
                analyzeLearnedPatterns(normalized);
                
                // Calculate feature importance (simplified)
                calculateFeatureImportance();

                // Cleanup tensors
                xTrainTensor.dispose();
                yTrainTensor.dispose();
                xTestTensor.dispose();
                yTestTensor.dispose();
                trainEval[0].dispose();
                trainEval[1].dispose();
                testEval[0].dispose();
                testEval[1].dispose();

            } catch (error) {
                trainingLog(`‚ùå Training error: ${error.message}`);
                console.error('Training error:', error);
            }
        });

        // Analyze what the network learned
        function analyzeLearnedPatterns(data) {
            const patterns = [];
            
            // Group data by status and analyze patterns
            const statusGroups = { 1: [], 2: [], 3: [] };
            data.forEach(row => {
                if (statusGroups[row.status]) {
                    statusGroups[row.status].push(row);
                }
            });
            
            Object.entries(statusGroups).forEach(([status, samples]) => {
                if (samples.length > 0) {
                    const avgWaterLevel = samples.reduce((sum, s) => sum + s.water_level, 0) / samples.length;
                    const avgRainfall = samples.reduce((sum, s) => sum + s.rainfall, 0) / samples.length;
                    
                    let patternDescription = `Status ${status}: `;
                    if (avgWaterLevel > 0.7) {
                        patternDescription += 'High water level';
                    } else if (avgWaterLevel > 0.3) {
                        patternDescription += 'Medium water level';
                    } else {
                        patternDescription += 'Low water level';
                    }
                    
                    if (avgRainfall > 0.5) {
                        patternDescription += ' + Heavy rainfall';
                    } else if (avgRainfall > 0.1) {
                        patternDescription += ' + Light rainfall';
                    } else {
                        patternDescription += ' + No rainfall';
                    }
                    
                    patterns.push({
                        status: status,
                        description: patternDescription,
                        samples: samples.length,
                        confidence: Math.min(95, 60 + (samples.length / data.length) * 100)
                    });
                }
            });
            
            // Display learned patterns
            const patternsDiv = document.getElementById('learnedPatterns');
            patternsDiv.innerHTML = '';
            
            patterns.forEach(pattern => {
                const div = document.createElement('div');
                div.className = 'pattern-card';
                div.innerHTML = `
                    <strong>${pattern.description}</strong><br>
                    <small>Learned from ${pattern.samples} samples (${pattern.confidence.toFixed(1)}% confidence)</small>
                `;
                patternsDiv.appendChild(div);
            });
        }

        // Calculate feature importance
        function calculateFeatureImportance() {
            // Simplified feature importance based on data variance and correlation
            const importance = {};
            
            featureNames.forEach(feature => {
                // Simple heuristic: features with more variance are more important
                const values = processedData.map(d => d[feature]).filter(v => !isNaN(v));
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const variance = values.reduce((sq, n) => sq + Math.pow(n - mean, 2), 0) / values.length;
                importance[feature] = Math.min(1, variance * 10); // Normalize to 0-1
            });
            
            // Display feature importance
            const importanceDiv = document.getElementById('featureImportance');
            importanceDiv.innerHTML = '';
            
            Object.entries(importance)
                .sort((a, b) => b[1] - a[1])
                .forEach(([feature, score]) => {
                    const div = document.createElement('div');
                    div.className = 'feature-bar';
                    div.innerHTML = `
                        <div class="feature-name">${feature.replace(/_/g, ' ').toUpperCase()}</div>
                        <div class="bar">
                            <div class="bar-fill" style="width: ${score * 100}%"></div>
                        </div>
                    `;
                    importanceDiv.appendChild(div);
                });
        }

        // Neural network prediction
        document.getElementById('predictButton').addEventListener('click', async function() {
            if (!model || !scaler) {
                alert('Please train the model first');
                return;
            }

            const waterLevel = parseFloat(document.getElementById('inputWaterLevel').value);
            const rainfall = parseFloat(document.getElementById('inputRainfall').value);
            const timeContext = parseFloat(document.getElementById('inputTimeContext').value);
            
            // Prepare input based on the features used during training
            const inputData = {
                water_level: waterLevel,
                rainfall: rainfall,
                hour_of_day: timeContext
            };
            
            // Add default values for other features
            featureNames.forEach(feature => {
                if (!inputData.hasOwnProperty(feature)) {
                    inputData[feature] = 0; // Default value
                }
            });
            
            // Normalize input
            const normalizedInput = featureNames.map(feature => {
                const { min, max } = scaler[feature];
                return max === min ? 0 : (inputData[feature] - min) / (max - min);
            });

            const inputTensor = tf.tensor2d([normalizedInput]);
            const prediction = model.predict(inputTensor);
            const probabilities = await prediction.data();
            
            const maxIndex = probabilities.indexOf(Math.max(...probabilities));
            const predictedStatus = maxIndex + 1;
            
            const statusNames = ['Status 1', 'Status 2', 'Status 3'];
            const statusColors = ['status-1', 'status-2', 'status-3'];
            const statusIcons = ['üü¢', 'üü°', 'üî¥'];
            
            const resultDiv = document.getElementById('predictionResult');
            resultDiv.className = `prediction-result ${statusColors[maxIndex]}`;
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = `
                ${statusIcons[maxIndex]} <strong>${statusNames[maxIndex]}</strong><br>
                Neural Network Confidence: ${(probabilities[maxIndex] * 100).toFixed(1)}%<br>
                <small>Water Level: ${waterLevel}cm | Rainfall: ${rainfall}mm/h | Time: ${timeContext}:00</small>
            `;
            
            // Show confidence bars
            document.getElementById('confidenceSection').style.display = 'block';
            
            statusNames.forEach((name, i) => {
                const confidence = probabilities[i] * 100;
                const confElement = document.getElementById(`conf${i + 1}`);
                confElement.style.width = confidence + '%';
                confElement.textContent = confidence.toFixed(1) + '%';
            });
            
            // Neural network reasoning
            const reasoningDiv = document.getElementById('reasoningText');
            let reasoning = 'Neural network decision based on: ';
            
            if (probabilities[0] > 0.5) {
                reasoning += 'Learned pattern suggests normal conditions with current input combination.';
            } else if (probabilities[1] > 0.5) {
                reasoning += 'Input features match warning condition patterns from training data.';
            } else {
                reasoning += 'High-risk pattern detected based on learned flood indicators.';
            }
            
            reasoningDiv.textContent = reasoning;
            document.getElementById('neuralExplanation').style.display = 'block';
            
            inputTensor.dispose();
            prediction.dispose();
        });

        // Auto-update prediction when inputs change
        let predictionTimeout;
        ['inputWaterLevel', 'inputRainfall', 'inputTimeContext'].forEach(id => {
            document.getElementById(id).addEventListener('input', function() {
                clearTimeout(predictionTimeout);
                predictionTimeout = setTimeout(() => {
                    if (model && scaler) {
                        document.getElementById('predictButton').click();
                    }
                }, 1000); // 1 second delay
            });
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            function checkLibraries() {
                if (typeof tf !== 'undefined' && typeof Papa !== 'undefined') {
                    log('üß† Pure Neural Network System Ready');
                    log('üéØ This system will learn patterns automatically from your data');
                    log('üìÅ Upload your CSV file to start automatic learning');
                    log('üìö Libraries loaded: TensorFlow.js ‚úÖ, PapaParse ‚úÖ');
                    
                    // Add automatic testing functionality
                    setTimeout(() => {
                        if (document.getElementById('addTestData')) return; // Prevent duplicate
                        addTestingFeature();
                    }, 1000);
                } else {
                    log('‚è≥ Loading neural network libraries...');
                    setTimeout(checkLibraries, 1000);
                }
            }
            checkLibraries();
        });

        // Add testing feature with 10 random test cases
        function addTestingFeature() {
            const testSection = document.createElement('div');
            testSection.className = 'section';
            testSection.id = 'testingSection';
            testSection.innerHTML = `
                <h2>üß™ Automatic Testing with 10 Random Cases</h2>
                <p style="text-align: center; opacity: 0.9;">
                    <em>Test the Neural Network with pre-generated random scenarios</em>
                </p>
                
                <div class="control-panel">
                    <div class="input-group">
                        <button id="generateTestData">üé≤ Generate 10 Random Test Cases</button>
                    </div>
                    <div class="input-group">
                        <button id="runAllTests">üöÄ Run All Tests (Auto-predict)</button>
                    </div>
                    <div class="input-group">
                        <button id="compareResults">üìä Compare with Expected Results</button>
                    </div>
                </div>
                
                <div id="testResults" class="test-results" style="display:none;">
                    <h3>üéØ Test Results:</h3>
                    <div id="testTable"></div>
                </div>
                
                <div id="accuracyAnalysis" class="learned-patterns" style="display:none;">
                    <h3>üìà Testing Accuracy Analysis:</h3>
                    <div id="accuracyDetails"></div>
                </div>
            `;
            
            // Insert before prediction section
            const predictionSection = document.getElementById('predictionSection');
            predictionSection.parentNode.insertBefore(testSection, predictionSection);
            
            // Add test data generation
            setupTestingEvents();
        }

        function setupTestingEvents() {
            // Generate random test data
            document.getElementById('generateTestData').addEventListener('click', function() {
                generateRandomTestCases();
            });
            
            // Run all tests
            document.getElementById('runAllTests').addEventListener('click', function() {
                if (!model || !scaler) {
                    alert('Please train the model first before running tests');
                    return;
                }
                runAllTestCases();
            });
            
            // Compare results
            document.getElementById('compareResults').addEventListener('click', function() {
                compareTestResults();
            });
        }

        let testCases = [];
        let testResults = [];

        function generateRandomTestCases() {
            testCases = [];
            
            // Generate 10 diverse test cases covering different scenarios
            const scenarios = [
                { name: "Normal Dry Condition", waterRange: [270, 300], rainfallRange: [0, 2], expected: 1 },
                { name: "Normal with Light Rain", waterRange: [250, 280], rainfallRange: [1, 5], expected: 1 },
                { name: "Warning Low Water", waterRange: [200, 240], rainfallRange: [0, 3], expected: 2 },
                { name: "Warning with Rain", waterRange: [180, 220], rainfallRange: [3, 8], expected: 2 },
                { name: "Danger High Water", waterRange: [100, 180], rainfallRange: [5, 15], expected: 3 },
                { name: "Critical Flood", waterRange: [50, 120], rainfallRange: [8, 20], expected: 3 },
                { name: "Edge Case 1", waterRange: [240, 260], rainfallRange: [2, 6], expected: 2 },
                { name: "Edge Case 2", waterRange: [160, 200], rainfallRange: [0, 4], expected: 2 },
                { name: "Extreme Rain", waterRange: [220, 250], rainfallRange: [15, 25], expected: 3 },
                { name: "Very High Water", waterRange: [280, 320], rainfallRange: [0, 1], expected: 1 }
            ];
            
            scenarios.forEach((scenario, i) => {
                const waterLevel = Math.random() * (scenario.waterRange[1] - scenario.waterRange[0]) + scenario.waterRange[0];
                const rainfall = Math.random() * (scenario.rainfallRange[1] - scenario.rainfallRange[0]) + scenario.rainfallRange[0];
                const timeContext = Math.floor(Math.random() * 24); // 0-23 hours
                
                testCases.push({
                    id: i + 1,
                    name: scenario.name,
                    waterLevel: parseFloat(waterLevel.toFixed(1)),
                    rainfall: parseFloat(rainfall.toFixed(1)),
                    timeContext: timeContext,
                    expected: scenario.expected,
                    predicted: null,
                    confidence: null
                });
            });
            
            displayTestCases();
            log(`üé≤ Generated 10 random test cases covering various scenarios`);
        }

        function displayTestCases() {
            document.getElementById('testResults').style.display = 'block';
            
            const tableHTML = `
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; background: rgba(255,255,255,0.1); border-radius: 10px; overflow: hidden;">
                        <thead>
                            <tr style="background: rgba(255,255,255,0.2);">
                                <th style="padding: 12px; border: 1px solid rgba(255,255,255,0.2);">Test #</th>
                                <th style="padding: 12px; border: 1px solid rgba(255,255,255,0.2);">Scenario</th>
                                <th style="padding: 12px; border: 1px solid rgba(255,255,255,0.2);">Water Level</th>
                                <th style="padding: 12px; border: 1px solid rgba(255,255,255,0.2);">Rainfall</th>
                                <th style="padding: 12px; border: 1px solid rgba(255,255,255,0.2);">Time</th>
                                <th style="padding: 12px; border: 1px solid rgba(255,255,255,0.2);">Expected</th>
                                <th style="padding: 12px; border: 1px solid rgba(255,255,255,0.2);">NN Prediction</th>
                                <th style="padding: 12px; border: 1px solid rgba(255,255,255,0.2);">Confidence</th>
                                <th style="padding: 12px; border: 1px solid rgba(255,255,255,0.2);">Result</th>
                            </tr>
                        </thead>
                        <tbody id="testTableBody">
                            ${testCases.map(test => `
                                <tr>
                                    <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1); text-align: center;">${test.id}</td>
                                    <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1);">${test.name}</td>
                                    <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1); text-align: center;">${test.waterLevel} cm</td>
                                    <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1); text-align: center;">${test.rainfall} mm/h</td>
                                    <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1); text-align: center;">${test.timeContext}:00</td>
                                    <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1); text-align: center;">Status ${test.expected}</td>
                                    <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1); text-align: center;" id="pred_${test.id}">-</td>
                                    <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1); text-align: center;" id="conf_${test.id}">-</td>
                                    <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1); text-align: center;" id="result_${test.id}">-</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            document.getElementById('testTable').innerHTML = tableHTML;
        }

        async function runAllTestCases() {
            if (!model || !scaler) {
                alert('Please train the model first');
                return;
            }

            log('üöÄ Running all 10 test cases through Neural Network...');
            testResults = [];
            
            for (let i = 0; i < testCases.length; i++) {
                const test = testCases[i];
                log(`Testing case ${i + 1}: ${test.name}`);
                
                // Prepare input data
                const inputData = {
                    water_level: test.waterLevel,
                    rainfall: test.rainfall,
                    hour_of_day: test.timeContext
                };
                
                // Add default values for other features
                featureNames.forEach(feature => {
                    if (!inputData.hasOwnProperty(feature)) {
                        if (feature.includes('change')) {
                            inputData[feature] = Math.random() * 10 - 5; // Random change -5 to +5
                        } else if (feature.includes('mean') || feature.includes('sum')) {
                            inputData[feature] = inputData.water_level || inputData.rainfall || 0;
                        } else {
                            inputData[feature] = 0;
                        }
                    }
                });
                
                // Normalize input
                const normalizedInput = featureNames.map(feature => {
                    const { min, max } = scaler[feature];
                    return max === min ? 0 : (inputData[feature] - min) / (max - min);
                });

                // Predict
                const inputTensor = tf.tensor2d([normalizedInput]);
                const prediction = model.predict(inputTensor);
                const probabilities = await prediction.data();
                
                const maxIndex = probabilities.indexOf(Math.max(...probabilities));
                const predictedStatus = maxIndex + 1;
                const confidence = probabilities[maxIndex] * 100;
                
                // Store results
                test.predicted = predictedStatus;
                test.confidence = confidence;
                
                const isCorrect = predictedStatus === test.expected;
                testResults.push({
                    ...test,
                    isCorrect: isCorrect,
                    probabilities: Array.from(probabilities)
                });
                
                // Update table
                document.getElementById(`pred_${test.id}`).textContent = `Status ${predictedStatus}`;
                document.getElementById(`conf_${test.id}`).textContent = `${confidence.toFixed(1)}%`;
                document.getElementById(`result_${test.id}`).innerHTML = isCorrect 
                    ? '<span style="color: #2ecc71;">‚úÖ Correct</span>' 
                    : '<span style="color: #e74c3c;">‚ùå Wrong</span>';
                
                // Color code the row
                const row = document.getElementById(`pred_${test.id}`).parentNode;
                row.style.backgroundColor = isCorrect 
                    ? 'rgba(46, 204, 113, 0.2)' 
                    : 'rgba(231, 76, 60, 0.2)';
                
                inputTensor.dispose();
                prediction.dispose();
                
                // Small delay for visual effect
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            log(`‚úÖ Completed all 10 test cases`);
            analyzeTestResults();
        }

        function analyzeTestResults() {
            const correctPredictions = testResults.filter(r => r.isCorrect).length;
            const accuracy = (correctPredictions / testResults.length) * 100;
            
            // Analyze by status
            const statusAnalysis = {};
            [1, 2, 3].forEach(status => {
                const statusTests = testResults.filter(r => r.expected === status);
                const statusCorrect = statusTests.filter(r => r.isCorrect).length;
                statusAnalysis[status] = {
                    total: statusTests.length,
                    correct: statusCorrect,
                    accuracy: statusTests.length > 0 ? (statusCorrect / statusTests.length) * 100 : 0
                };
            });
            
            // Calculate confidence statistics
            const confidences = testResults.map(r => r.confidence);
            const avgConfidence = confidences.reduce((a, b) => a + b, 0) / confidences.length;
            const minConfidence = Math.min(...confidences);
            const maxConfidence = Math.max(...confidences);
            
            document.getElementById('accuracyAnalysis').style.display = 'block';
            document.getElementById('accuracyDetails').innerHTML = `
                <div class="pattern-card">
                    <h4>üéØ Overall Testing Results</h4>
                    <strong>Overall Accuracy: ${accuracy.toFixed(1)}% (${correctPredictions}/${testResults.length})</strong><br>
                    Average Confidence: ${avgConfidence.toFixed(1)}%<br>
                    Confidence Range: ${minConfidence.toFixed(1)}% - ${maxConfidence.toFixed(1)}%
                </div>
                
                <div class="pattern-card">
                    <h4>üìä Accuracy by Status</h4>
                    ${Object.entries(statusAnalysis).map(([status, stats]) => 
                        `Status ${status}: ${stats.accuracy.toFixed(1)}% (${stats.correct}/${stats.total})`
                    ).join('<br>')}
                </div>
                
                <div class="pattern-card">
                    <h4>üîç Detailed Analysis</h4>
                    ${analyzeDetailedResults()}
                </div>
            `;
            
            log(`üìä Test Results: ${accuracy.toFixed(1)}% accuracy with ${avgConfidence.toFixed(1)}% average confidence`);
        }

        function analyzeDetailedResults() {
            const wrongPredictions = testResults.filter(r => !r.isCorrect);
            
            if (wrongPredictions.length === 0) {
                return '<span style="color: #2ecc71;">üéâ Perfect! All predictions were correct!</span>';
            }
            
            let analysis = '<strong>Incorrect Predictions Analysis:</strong><br>';
            wrongPredictions.forEach(test => {
                analysis += `‚Ä¢ Test ${test.id} (${test.name}): Expected Status ${test.expected}, Got Status ${test.predicted} (${test.confidence.toFixed(1)}% confidence)<br>`;
            });
            
            // Common error patterns
            const errorPatterns = wrongPredictions.reduce((patterns, test) => {
                const errorType = `${test.expected}‚Üí${test.predicted}`;
                patterns[errorType] = (patterns[errorType] || 0) + 1;
                return patterns;
            }, {});
            
            if (Object.keys(errorPatterns).length > 0) {
                analysis += '<br><strong>Common Error Patterns:</strong><br>';
                Object.entries(errorPatterns).forEach(([pattern, count]) => {
                    analysis += `‚Ä¢ Status ${pattern}: ${count} occurrence(s)<br>`;
                });
            }
            
            return analysis;
        }

        function compareTestResults() {
            if (testResults.length === 0) {
                alert('Please run the tests first');
                return;
            }
            
            // Create comparison visualization
            const comparisonHTML = `
                <div class="pattern-card">
                    <h4>üìà Expected vs Predicted Comparison</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; margin: 15px 0;">
                        ${testResults.map(test => `
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; ${test.isCorrect ? 'border-left: 4px solid #2ecc71;' : 'border-left: 4px solid #e74c3c;'}">
                                <strong>${test.name}</strong><br>
                                Input: ${test.waterLevel}cm, ${test.rainfall}mm/h<br>
                                Expected: <span class="status-${test.expected}" style="padding: 2px 8px; border-radius: 4px; font-size: 0.9em;">Status ${test.expected}</span><br>
                                Neural Network: <span class="status-${test.predicted}" style="padding: 2px 8px; border-radius: 4px; font-size: 0.9em;">Status ${test.predicted}</span> (${test.confidence.toFixed(1)}%)<br>
                                ${test.isCorrect ? '<span style="color: #2ecc71;">‚úÖ Correct</span>' : '<span style="color: #e74c3c;">‚ùå Incorrect</span>'}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            
            document.getElementById('accuracyDetails').innerHTML += comparisonHTML;
            log('üìä Detailed comparison completed');
        }
    </script>
</body>
</html>
    </script>
</body>
</html>